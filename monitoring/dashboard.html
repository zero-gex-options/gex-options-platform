<!DOCTYPE html>
<html>
<head>
    <title>ZeroGEX Monitoring Dashboard</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.3.0/build/global/luxon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.1.1/dist/chartjs-chart-financial.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 250px;
            background: #1e293b;
            border-right: 1px solid #334155;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 24px 20px;
            border-bottom: 1px solid #334155;
        }
        .sidebar-header h1 {
            font-size: 20px;
            margin-bottom: 4px;
        }
        .sidebar-header .status {
            font-size: 12px;
            color: #94a3b8;
        }
        .nav-menu {
            flex: 1;
            padding: 16px 0;
            overflow-y: auto;
        }
        .nav-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            color: #94a3b8;
        }
        .nav-item:hover {
            background: #334155;
            color: #e2e8f0;
        }
        .nav-item.active {
            background: #334155;
            color: #60a5fa;
            border-left: 3px solid #60a5fa;
        }
        .nav-icon {
            font-size: 18px;
        }
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        .page {
            display: none;
            animation: fadeIn 0.3s;
        }
        .page.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .page-header {
            margin-bottom: 24px;
        }
        .page-header h2 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        .page-header .subtitle {
            color: #94a3b8;
            font-size: 14px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .card {
            background: #1e293b;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #334155;
        }
        .card h3 {
            font-size: 16px;
            margin-bottom: 16px;
            color: #60a5fa;
        }
        .metric {
            margin-bottom: 12px;
        }
        .metric-label {
            color: #94a3b8;
            font-size: 12px;
            margin-bottom: 4px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: #e2e8f0;
        }
        .metric-value.large {
            font-size: 48px;
            color: #60a5fa;
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
        .status-badge.success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }
        .status-badge.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        .status-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }
        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }
        .progress-bar {
            background: #334155;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }
        .progress-fill {
            height: 100%;
            transition: width 0.3s;
        }
        .progress-fill.green { background: #10b981; }
        .progress-fill.yellow { background: #f59e0b; }
        .progress-fill.red { background: #ef4444; }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .data-table th {
            background: #334155;
            padding: 12px;
            text-align: left;
            color: #94a3b8;
            font-weight: 500;
            position: sticky;
            top: 0;
        }
        .data-table td {
            padding: 12px;
            border-bottom: 1px solid #334155;
        }
        .data-table tr:hover {
            background: #1e293b;
        }
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 16px;
        }
        .alert-item {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid #ef4444;
            padding: 12px 16px;
            margin-bottom: 12px;
            border-radius: 6px;
        }
        .alert-item.warning {
            background: rgba(245, 158, 11, 0.1);
            border-left-color: #f59e0b;
        }
        .alert-time {
            color: #94a3b8;
            font-size: 11px;
            margin-bottom: 4px;
        }
        .alert-message {
            font-size: 13px;
        }
        .market-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }
	.market-status.open {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }
        .market-status.pre-market,
        .market-status.after-hours {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }
        .market-status.closed,
        .market-status.unknown {
            background: rgba(148, 163, 184, 0.2);
            color: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>ZeroGEX Monitoring</h1>
            <div class="status" id="lastUpdate">Loading...</div>
            <div style="margin-top: 8px;" id="marketStatusBadge"></div>
        </div>
        <nav class="nav-menu">
            <div class="nav-item active" onclick="showPage('home')">
                <span class="nav-icon">üìä</span>
                <span>Dashboard</span>
            </div>
            <div class="nav-item" onclick="showPage('system')">
                <span class="nav-icon">üíª</span>
                <span>System Resources</span>
            </div>
            <div class="nav-item" onclick="showPage('services')">
                <span class="nav-icon">‚öôÔ∏è</span>
                <span>Service Status</span>
            </div>
            <div class="nav-item" onclick="showPage('database')">
                <span class="nav-icon">üóÑÔ∏è</span>
                <span>Database Metrics</span>
            </div>
            <div class="nav-item" onclick="showPage('alerts')">
                <span class="nav-icon">‚ö†Ô∏è</span>
                <span>Active Alerts</span>
            </div>
            <div class="nav-item" onclick="showPage('spy')">
                <span class="nav-icon">üìà</span>
                <span>SPY Quote</span>
            </div>
            <div class="nav-item" onclick="showPage('ingestion')">
                <span class="nav-icon">üì•</span>
                <span>Ingestion Metrics</span>
            </div>
            <div class="nav-item" onclick="showPage('options')">
                <span class="nav-icon">üìã</span>
                <span>Option Quotes</span>
            </div>
            <div class="nav-item" onclick="showPage('uptime')">
                <span class="nav-icon">‚è±Ô∏è</span>
                <span>System Uptime</span>
            </div>
        </nav>
        <div style="padding: 0px; border-top: 1px solid #334155; text-align: center;">
            <img src="/logo" alt="ZeroGEX‚Ñ¢" style="width: 100%; max-width: 250px; opacity: 0.8;">
        </div>
    </div>

    <div class="main-content">
        <!-- Home Page -->
        <div id="home" class="page active">
            <div class="page-header">
                <h2>System Dashboard</h2>
                <div class="subtitle">Quick overview of system health</div>
            </div>
            <div class="grid">
                <div class="card"><h3>System Health</h3><div id="homeSystemHealth">Loading...</div></div>
                <div class="card"><h3>Services</h3><div id="homeServices">Loading...</div></div>
                <div class="card"><h3>Data Flow</h3><div id="homeDataFlow">Loading...</div></div>
            </div>
        </div>

        <!-- System Resources Page -->
        <div id="system" class="page">
            <div class="page-header">
                <h2>System Resources</h2>
                <div class="subtitle">CPU, Memory, and Disk usage</div>
            </div>
            <div class="grid">
                <div class="card"><h3>CPU Usage</h3><div id="systemCPU">Loading...</div></div>
                <div class="card"><h3>Memory Usage</h3><div id="systemMemory">Loading...</div></div>
                <div class="card"><h3>Disk Usage</h3><div id="systemDisk">Loading...</div></div>
            </div>
        </div>

        <!-- Service Status Page -->
        <div id="services" class="page">
            <div class="page-header">
                <h2>Service Status</h2>
                <div class="subtitle">Status of all system services</div>
            </div>
            <div class="card">
                <div id="servicesContent" style="max-width: 600px; margin: 0 auto;">Loading...</div>
            </div>
        </div>

        <!-- Database Metrics Page -->
        <div id="database" class="page">
            <div class="page-header">
                <h2>Database Metrics</h2>
                <div class="subtitle">Database statistics and performance</div>
            </div>
            <div class="grid">
                <div class="card"><h3>Quote Statistics</h3><div id="dbQuoteStats">Loading...</div></div>
                <div class="card"><h3>Database Info</h3><div id="dbInfo">Loading...</div></div>
            </div>
            <div class="card" style="margin-top: 20px;">
                <h3>Database Tables <span style="color: #94a3b8; font-size: 12px; font-weight: normal;">(Click to view recent records)</span></h3>
                <div style="display: flex; gap: 16px; margin-top: 16px; flex-wrap: wrap;">
                    <div onclick="showTableData('options_quotes')" style="cursor: pointer; padding: 20px; background: #0f172a; border-radius: 8px; text-align: center; flex: 1; min-width: 150px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">üìä</div>
                        <div style="font-size: 14px; color: #e2e8f0;">Options Quotes</div>
                    </div>
                    <div onclick="showTableData('underlying_quotes')" style="cursor: pointer; padding: 20px; background: #0f172a; border-radius: 8px; text-align: center; flex: 1; min-width: 150px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">üí∞</div>
                        <div style="font-size: 14px; color: #e2e8f0;">Underlying Prices</div>
                    </div>
                    <div onclick="showTableData('gex_metrics')" style="cursor: pointer; padding: 20px; background: #0f172a; border-radius: 8px; text-align: center; flex: 1; min-width: 150px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">‚ö°</div>
                        <div style="font-size: 14px; color: #e2e8f0;">Latest GEX</div>
                    </div>
                    <div onclick="showTableData('ingestion_metrics')" style="cursor: pointer; padding: 20px; background: #0f172a; border-radius: 8px; text-align: center; flex: 1; min-width: 150px;">
                        <div style="font-size: 32px; margin-bottom: 8px;">üì•</div>
                        <div style="font-size: 14px; color: #e2e8f0;">Ingestion Metrics</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Alerts Page -->
        <div id="alerts" class="page">
            <div class="page-header">
                <h2>Active Alerts</h2>
                <div class="subtitle">System warnings and errors</div>
            </div>
            <div class="card">
                <div id="alertsContent">Loading...</div>
            </div>
        </div>

        <!-- SPY Quote Page -->
        <div id="spy" class="page">
            <div class="page-header">
                <h2>SPY Quote</h2>
                <div class="subtitle">Latest SPY pricing and volume</div>
            </div>
	    <div class="card" style="margin-bottom: 20px; padding: 16px;">
                <div id="spyLatest">Loading...</div>
            </div>
            <div class="card" style="padding: 24px 24px 0 24px;">
                <h3 style="margin-bottom: 16px;">Price, Volume & Open Interest</h3>
                <!-- Candlestick Chart -->
                <div class="chart-container" style="height: 400px; margin-bottom: 0; padding-bottom: 16px; border-bottom: 2px solid #334155;">
                    <canvas id="spyCandlestickChart"></canvas>
                </div>
                <!-- Volume Chart -->
                <div class="chart-container" style="height: 300px; margin-top: 16px; margin-bottom: 0; padding-bottom: 16px; border-bottom: 2px solid #334155;">
                    <canvas id="spyVolumeChart"></canvas>
                </div>
                <!-- Open Interest Chart -->
                <div class="chart-container" style="height: 350px; margin-top: 16px; padding-bottom: 24px;">
                    <canvas id="spyOIChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Ingestion Metrics Page -->
        <div id="ingestion" class="page">
            <div class="page-header">
                <h2>Ingestion Metrics</h2>
                <div class="subtitle">Data ingestion performance</div>
            </div>
            <div class="card" style="margin-bottom: 20px;">
                <h3>Latest Metrics</h3>
                <div id="ingestionLatest">Loading...</div>
            </div>
            <div class="card">
                <h3>48-Hour History</h3>
                <div class="chart-container" style="height: 400px;">
                    <canvas id="ingestionCombinedChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Option Quotes Page -->
        <div id="options" class="page">
            <div class="page-header">
                <h2>Recent Option Quotes</h2>
                <div class="subtitle">Last 50 options received</div>
            </div>
            <div class="card">
                <div style="overflow-x: auto;">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Symbol</th><th>Strike</th><th>Exp</th><th>DTE</th><th>Type</th>
                                <th>Last</th><th>Bid</th><th>Ask</th><th>Mid</th><th>Vol</th>
                                <th>OI</th><th>IV</th><th>Delta</th><th>Gamma</th><th>Time</th>
                            </tr>
                        </thead>
                        <tbody id="optionsTableBody">
                            <tr><td colspan="15">Loading...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- System Uptime Page -->
        <div id="uptime" class="page">
            <div class="page-header">
                <h2>System Uptime</h2>
                <div class="subtitle">Service availability timeline</div>
            </div>
            <div class="card">
                <div class="chart-container" style="height: 400px;">
                    <canvas id="uptimeChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let globalData = {};
        let charts = {}; // Will now hold spyPriceChart, spyVolumeChart, etc.

        // Add caching system
        let chartDataCache = {
            spy: { data: [], lastUpdate: 0 },
            ingestion: { data: [], lastUpdate: 0 }
        };

        const CACHE_TTL = 25000; // 25 seconds (less than server-side 30s cache)

        function isCacheValid(cacheKey) {
            return (Date.now() - chartDataCache[cacheKey].lastUpdate) < CACHE_TTL;
        }

        function updateCache(cacheKey, newData) {
            chartDataCache[cacheKey].data = newData;
            chartDataCache[cacheKey].lastUpdate = Date.now();
            return newData;
        }

        // Market hours background zones plugin
        const marketHoursBackgroundPlugin = {
            id: 'marketHoursBackground',
            beforeDatasetsDraw: (chart) => {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                const xScale = chart.scales.x;

                if (!xScale || !chartArea) return;

                ctx.save();

                // Define market hour zones (Eastern Time)
                const zones = [
                    { start: 4, end: 9.5, color: 'rgba(251, 146, 60, 0.08)' },    // Pre-market
                    { start: 9.5, end: 16, color: 'transparent' },                 // Regular hours
                    { start: 16, end: 20, color: 'rgba(251, 146, 60, 0.08)' }     // After-hours
                ];

                // Get visible time range
                const minTime = xScale.min;
                const maxTime = xScale.max;

                // Iterate through each visible data point's day
                const dataPoints = chart.data.datasets[0]?.data || [];
                if (dataPoints.length === 0) return;

                // Group data points by day
                const dayGroups = {};
                dataPoints.forEach(point => {
                    const date = new Date(point.x);
                    const dayKey = date.toLocaleDateString('en-US', { 
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit'
                    });

                    if (!dayGroups[dayKey]) {
                        dayGroups[dayKey] = [];
                    }
                    dayGroups[dayKey].push(date);
                });

                // For each day, draw the zones
                Object.keys(dayGroups).forEach(dayKey => {
                    const dayDate = new Date(dayGroups[dayKey][0]);

                    // Set to midnight ET for this day
                    const midnightET = new Date(dayDate.toLocaleString('en-US', { timeZone: 'America/New_York' }));
                    midnightET.setHours(0, 0, 0, 0);

                    zones.forEach(zone => {
                        // Calculate start and end times for this zone
                        const zoneStart = new Date(midnightET);
                        const startHours = Math.floor(zone.start);
                        const startMinutes = (zone.start % 1) * 60;
                        zoneStart.setHours(startHours, startMinutes, 0, 0);

                        const zoneEnd = new Date(midnightET);
                        const endHours = Math.floor(zone.end);
                        const endMinutes = (zone.end % 1) * 60;
                        zoneEnd.setHours(endHours, endMinutes, 0, 0);

                        // Convert to timestamps
                        const zoneStartTime = zoneStart.getTime();
                        const zoneEndTime = zoneEnd.getTime();

                        // Check if zone is in visible range
                        if (zoneEndTime < minTime || zoneStartTime > maxTime) return;

                        // Calculate pixel positions
                        const startX = xScale.getPixelForValue(Math.max(zoneStartTime, minTime));
                        const endX = xScale.getPixelForValue(Math.min(zoneEndTime, maxTime));

                        // Draw the zone
                        if (zone.color !== 'transparent' && endX > startX) {
                            ctx.fillStyle = zone.color;
                            ctx.fillRect(
                                startX,
                                chartArea.top,
                                endX - startX,
                                chartArea.bottom - chartArea.top
                            );
                        }
                    });
                });

                ctx.restore();
            }
        };

        // Register the plugin
        if (typeof Chart !== 'undefined') {
            Chart.register(marketHoursBackgroundPlugin);
        }

        window.showTableData = async function(tableName) {
            try {
                const response = await fetch(`/api/table/${tableName}`);
                const data = await response.json();
                if (data.error) { alert(`Error: ${data.error}`); return; }
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1e293b; padding: 24px; border-radius: 8px; max-width: 90vw; max-height: 80vh; overflow: auto; z-index: 1000; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.5);';
                let html = `<h3 style="margin-top: 0; color: #e2e8f0;">${tableName} (Last 100 rows)</h3>`;
                html += `<button onclick="this.parentElement.remove(); document.getElementById('modalOverlay').remove();" style="position: absolute; top: 12px; right: 12px; background: #334155; border: none; color: #e2e8f0; padding: 8px 12px; border-radius: 4px; cursor: pointer;">Close</button>`;
                html += '<div style="overflow-x: auto;"><table style="width: 100%; border-collapse: collapse; font-size: 12px;">';
                if (data.length > 0) {
                    html += '<thead><tr>';
                    Object.keys(data[0]).forEach(key => { html += `<th style="padding: 8px; text-align: left; border-bottom: 2px solid #334155; color: #94a3b8;">${key}</th>`; });
                    html += '</tr></thead><tbody>';
                    data.forEach(row => {
                        html += '<tr style="border-bottom: 1px solid #334155;">';
                        Object.values(row).forEach(val => { html += `<td style="padding: 8px; color: #e2e8f0;">${val !== null ? val : 'NULL'}</td>`; });
                        html += '</tr>';
                    });
                    html += '</tbody>';
                }
                html += '</table></div>';
                modal.innerHTML = html;
                const overlay = document.createElement('div');
                overlay.id = 'modalOverlay';
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 999;';
                overlay.onclick = () => { modal.remove(); overlay.remove(); };
                document.body.appendChild(overlay);
                document.body.appendChild(modal);
            } catch (error) {
                console.error('Error fetching table data:', error);
                alert('Failed to fetch table data');
            }
        }

        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');
            event.target.closest('.nav-item').classList.add('active');
        }

        function formatNumber(num) { return new Intl.NumberFormat().format(num); }
        function getProgressColor(value) { return value >= 90 ? 'red' : value >= 80 ? 'yellow' : 'green'; }
        function renderProgressBar(value) {
            const color = getProgressColor(value);
            return `<div class="progress-bar"><div class="progress-fill ${color}" style="width: ${value}%"></div></div>`;
        }

        function updateMarketStatus() {
            fetch('/api/market-status').then(response => response.json()).then(status => {
                const marketBadge = document.getElementById('marketStatusBadge');
                marketBadge.innerHTML = `<span class="market-status ${status.status}">${status.icon} ${status.label}</span>`;
            }).catch(error => {
                console.error('Error fetching market status:', error);
                const marketBadge = document.getElementById('marketStatusBadge');
                marketBadge.innerHTML = '<span class="market-status unknown">‚ùì Status Unknown</span>';
            });
        }

        function updateHome(data) {
            // Check if data.system exists
            if (!data.system) {
                document.getElementById('homeSystemHealth').innerHTML = '<div style="color: #ef4444;">System metrics unavailable</div>';
                return;
            }

            const sys = data.system;
            const maxUsage = Math.max(sys.cpu_percent, sys.memory_percent, sys.disk_percent);
            const healthStatus = maxUsage >= 90 ? 'error' : maxUsage >= 80 ? 'warning' : 'success';
            const healthText = maxUsage >= 90 ? 'Critical' : maxUsage >= 80 ? 'Warning' : 'Healthy';

            document.getElementById('homeSystemHealth').innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="status-badge ${healthStatus}" style="font-size: 16px; padding: 8px 16px;">
                        <span class="status-dot"></span>${healthText}
                    </div>
                    <div style="margin-top: 12px; color: #94a3b8; font-size: 14px;">
                        CPU: ${sys.cpu_percent.toFixed(1)}% | Mem: ${sys.memory_percent.toFixed(1)}% | Disk: ${sys.disk_percent.toFixed(1)}%
                    </div>
                </div>`;

            let allActive = data.services && Object.values(data.services).every(s => s === 'active');
            document.getElementById('homeServices').innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div class="status-badge ${allActive ? 'success' : 'error'}" style="font-size: 16px; padding: 8px 16px;">
                        <span class="status-dot"></span>${allActive ? 'All Running' : 'Issues Detected'}
                    </div>
                    <div style="margin-top: 12px; color: #94a3b8; font-size: 14px;">${data.services ? Object.keys(data.services).length : 0} services monitored</div>
                </div>`;

            if (data.database && !data.database.error) {
                const db = data.database;
                document.getElementById('homeDataFlow').innerHTML = `
                    <div style="padding: 12px;">
                        <div class="metric"><div class="metric-label">Recent Quotes (10 min)</div><div class="metric-value">${formatNumber(db.quotes_recent_10min)}</div></div>
                        <div class="metric"><div class="metric-label">Total Option Quotes (All Time)</div><div class="metric-value" style="font-size: 18px;">${formatNumber(db.quotes_total)}</div></div>
                    </div>`;
            }

        }

        function updateSystem(data) {
            const sys = data.system;
            document.getElementById('systemCPU').innerHTML = `<div class="metric-value">${sys.cpu_percent.toFixed(1)}%</div>${renderProgressBar(sys.cpu_percent)}`;
            document.getElementById('systemMemory').innerHTML = `<div class="metric-value">${sys.memory_percent.toFixed(1)}%</div><div style="color: #94a3b8; font-size: 12px; margin-top: 4px;">${sys.memory_used_gb.toFixed(1)} GB / ${sys.memory_total_gb.toFixed(1)} GB</div>${renderProgressBar(sys.memory_percent)}`;
            document.getElementById('systemDisk').innerHTML = `<div class="metric-value">${sys.disk_percent.toFixed(1)}%</div><div style="color: #94a3b8; font-size: 12px; margin-top: 4px;">${sys.disk_used_gb.toFixed(1)} GB / ${sys.disk_total_gb.toFixed(1)} GB</div>${renderProgressBar(sys.disk_percent)}`;
        }

        function updateServices(data) {
            let html = '<div style="display: grid; gap: 12px;">';
            for (const [service, status] of Object.entries(data.services)) {
                const isActive = status === 'active';
                html += `<div style="padding: 16px; background: #0f172a; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-size: 14px;">${service}</span>
                    <span class="status-badge ${isActive ? 'success' : 'error'}"><span class="status-dot"></span>${status}</span>
                </div>`;
            }
            html += '</div>';
            document.getElementById('servicesContent').innerHTML = html;
        }

        function updateDatabase(data) {
            if (!data.database || data.database.error) {
                document.getElementById('dbQuoteStats').innerHTML = '<div style="color: #ef4444;">Database unavailable</div>';
                return;
            }
            const db = data.database;
            document.getElementById('dbQuoteStats').innerHTML = `
                <div class="metric"><div class="metric-label">Total Quotes</div><div class="metric-value">${formatNumber(db.quotes_total)}</div></div>
                <div class="metric"><div class="metric-label">Recent (10 min)</div><div class="metric-value">${formatNumber(db.quotes_recent_10min)}</div></div>
                <div class="metric"><div class="metric-label">Recent (1 hour)</div><div class="metric-value">${formatNumber(db.quotes_recent_1hour)}</div></div>
                <div class="metric"><div class="metric-label">GEX Calculations</div><div class="metric-value">${formatNumber(db.gex_count)}</div></div>`;
            document.getElementById('dbInfo').innerHTML = `
                <div class="metric"><div class="metric-label">Database Size</div><div class="metric-value" style="font-size: 18px;">${db.db_size}</div></div>
                <div class="metric"><div class="metric-label">Active Connections</div><div class="metric-value">${db.active_connections}</div></div>`;
        }

        function updateAlerts(data) {
            const alerts = data.alerts || [];
            if (alerts.length === 0) {
                document.getElementById('alertsContent').innerHTML = '<div style="color: #10b981; text-align: center; padding: 40px;">‚úì All systems operational</div>';
                return;
            }
            let html = '';
            alerts.forEach(alert => {
                const time = new Date(alert.timestamp).toLocaleTimeString();
                html += `<div class="alert-item ${alert.level}"><div class="alert-time">${time} - ${alert.category}</div><div class="alert-message">${alert.message}</div></div>`;
            });
            document.getElementById('alertsContent').innerHTML = html;
        }

        async function updateSPY(data) {
            // Quote panel is now updated directly by updateSPYChart
            await updateSPYChart();
        }

        async function updateSPYChart() {
            try {
                // Check cache first
                if (isCacheValid('spy') && chartDataCache.spy.data.length > 0) {
                    console.log('Using cached SPY data');
                    const data = chartDataCache.spy.data;
                    // Skip to rendering (jump to line with "Filter out weekends")
                } else {
                    const response = await fetch('/api/spy-history');
                    const data = await response.json();

                    console.log('SPY API Response:', data);

                    if (data.error) {
                        console.error('SPY API Error:', data.error);
                        return;
                    }

                    if (!data || data.length === 0) {
                        console.log('No SPY history data available');
                        return;
                    }

                    // Update cache
                    updateCache('spy', data);
                }

                const data = chartDataCache.spy.data;

                // Filter out weekends (Saturday=6, Sunday=0)
                const filteredData = data.filter(d => {
                    if (!d.timestamp) return false;
                    const date = new Date(d.timestamp);
                    if (isNaN(date.getTime())) {
                        console.warn('Invalid timestamp:', d.timestamp);
                        return false;
                    }
                    const day = date.getDay();
                    return day !== 0 && day !== 6;
                });

                if (filteredData.length === 0) { 
                    console.log('No weekday SPY data after filtering'); 
                    return; 
                }

                console.log('Filtered data points:', filteredData.length);
                console.log('Sample data point:', filteredData[0]);

                // Destroy old charts
                if (charts.spyPriceChart) {
                    charts.spyPriceChart.destroy();
                    charts.spyPriceChart = null;
                }
                if (charts.spyVolumeChart) {
                    charts.spyVolumeChart.destroy();
                    charts.spyVolumeChart = null;
                }
                if (charts.spyOIChart) {
                    charts.spyOIChart.destroy();
                    charts.spyOIChart = null;
                }

                // Check if Chart and required plugins are loaded
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js not loaded');
                    return;
                }

                // Candlestick Chart (top)
                const candlestickCtx = document.getElementById('spyCandlestickChart');
                if (!candlestickCtx) {
                    console.error('Candlestick canvas not found');
                    return;
                }

                // Prepare OHLC data
                const ohlcData = filteredData.map(d => {
                    const timestamp = new Date(d.timestamp).getTime();
                    return {
                        x: timestamp,
                        o: d.open || d.close,
                        h: d.high || d.close,
                        l: d.low || d.close,
                        c: d.close
                    };
                });

                console.log('OHLC data prepared:', ohlcData.length, 'points');
                console.log('Sample OHLC:', ohlcData[0]);

                try {
                    charts.spyPriceChart = new Chart(candlestickCtx, {
                        type: 'candlestick',
                        data: {
                            datasets: [{
                                label: 'SPY',
                                data: ohlcData,
                                borderColor: {
                                    up: '#059669',
                                    down: '#dc2626',
                                    unchanged: '#64748b'
                                },
                                backgroundColor: {
                                    up: 'rgba(16, 185, 129, 0.5)',
                                    down: 'rgba(239, 68, 68, 0.5)',
                                    unchanged: 'rgba(148, 163, 184, 0.5)'
                                }
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        unit: 'minute',
                                        stepSize: 30,
                                        displayFormats: { 
                                            minute: 'MMM dd HH:mm'
                                        }
                                    },
                                    ticks: {
                                        color: '#94a3b8',
                                        callback: function(value, index, ticks) {
                                            const date = new Date(value);
                                            const minutes = date.getMinutes();
                                            // Show label every 30 minutes (00 and 30)
                                            if (minutes === 0 || minutes === 30) {
                                                return date.toLocaleString('en-US', { 
                                                    month: 'short', 
                                                    day: 'numeric',
                                                    hour: '2-digit',
                                                    minute: '2-digit'
                                                });
                                            }
                                            return '';
                                        }
                                    },
                                    display: false
                                },
                                y: {
                                    title: { display: true, text: 'Price ($)', color: '#94a3b8' },
                                    ticks: { 
                                        color: '#94a3b8',
                                        callback: function(value) {
                                            return '$' + value.toFixed(2);
                                        }
                                    },
                                    grid: { color: '#334155' }
                                }
                            },
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            const date = new Date(context[0].parsed.x);
                                            return date.toLocaleString('en-US', {
                                                month: 'short',
                                                day: 'numeric',
                                                hour: '2-digit',
                                                minute: '2-digit'
                                            });
                                        },
                                        label: function(context) {
                                            const dataPoint = context.raw;
                                            const idx = context.dataIndex;

                                            // Calculate change from previous bar
                                            let changeText = '';
                                            if (idx > 0) {
                                                const prevClose = ohlcData[idx - 1].c;
                                                const currentClose = dataPoint.c;
                                                const change = currentClose - prevClose;
                                                const changePct = (change / prevClose) * 100;
                                                const changeSymbol = change >= 0 ? '+' : '';
                                                changeText = `\nChange: ${changeSymbol}$${change.toFixed(2)} (${changeSymbol}${changePct.toFixed(2)}%)`;
                                            }

                                            return [
                                                `Open: $${dataPoint.o.toFixed(2)}`,
                                                `High: $${dataPoint.h.toFixed(2)}`,
                                                `Low: $${dataPoint.l.toFixed(2)}`,
                                                `Close: $${dataPoint.c.toFixed(2)}`,
                                                changeText
                                            ].filter(Boolean);
                                        }
                                    }
                                }
                            }
                        }
                    });
                    console.log('Candlestick chart created');
                } catch (e) {
                    console.error('Error creating candlestick chart:', e);
                    // Fallback to line chart if candlestick fails
                    charts.spyPriceChart = new Chart(candlestickCtx, {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: 'SPY Price',
                                data: filteredData.map(d => ({
                                    x: new Date(d.timestamp).getTime(),
                                    y: d.close
                                })),
                                borderColor: '#60a5fa',
                                backgroundColor: 'rgba(96, 165, 250, 0.1)',
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: { 
                                        unit: 'minute',
                                        stepSize: 30,
                                        displayFormats: { minute: 'MMM dd HH:mm' } 
                                    },
                                    ticks: { color: '#94a3b8' },
                                    display: false
                                },
                                y: {
                                    title: { display: true, text: 'Price ($)', color: '#94a3b8' },
                                    ticks: { color: '#94a3b8' },
                                    grid: { color: '#334155' }
                                }
                            },
                            plugins: { legend: { display: false } }
                        }
                    });
                    console.log('Fallback line chart created');
                }

                // Volume Chart (middle)
                const volumeCtx = document.getElementById('spyVolumeChart');
                charts.spyVolumeChart = new Chart(volumeCtx, {
                    type: 'bar',
                    data: {
                        datasets: [
                            {
                                label: 'Down Volume',
                                data: filteredData.map(d => ({
                                    x: new Date(d.timestamp).getTime(),
                                    y: d.down_volume || 0
                                })),
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                stack: 'volume'
                            },
                            {
                                label: 'Up Volume',
                                data: filteredData.map(d => ({
                                    x: new Date(d.timestamp).getTime(),
                                    y: d.up_volume || 0
                                })),
                                backgroundColor: 'rgba(16, 185, 129, 0.7)',
                                stack: 'volume'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            x: {
                                type: 'time',
                                stacked: true,
                                time: { 
                                    unit: 'minute',
                                    stepSize: 30,
                                    displayFormats: { minute: 'MMM dd HH:mm' } 
                                },
                                ticks: { color: '#94a3b8' },
                                display: false
                            },
                            y: {
                                stacked: true,
                                title: { display: true, text: 'Volume', color: '#94a3b8' },
                                ticks: { 
                                    color: '#94a3b8',
                                    callback: function(value) {
                                        return (value / 1000000).toFixed(1) + 'M';
                                    }
                                },
                                grid: { color: '#334155' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#e2e8f0' }, position: 'top' }
                        }
                    }
                });
                console.log('Volume chart created');

                // Open Interest Chart (bottom) - EXCLUDE LAST DATA POINT
                const oiCtx = document.getElementById('spyOIChart');

                // Remove the last data point (most recent, partial data)
                const oiData = filteredData.slice(0, -1);

                console.log('Creating OI chart with data points:', oiData.length, '(excluded last point)');
                console.log('Sample OI data:', oiData[0]);

                charts.spyOIChart = new Chart(oiCtx, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Call Notional Value',
                                data: oiData.map(d => ({
                                    x: new Date(d.timestamp).getTime(),
                                    y: d.call_notional || 0
                                })),
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 5,
                                tension: 0.4,
                                fill: true
                            },
                            {
                                label: 'Put Notional Value',
                                data: oiData.map(d => ({
                                    x: new Date(d.timestamp).getTime(),
                                    y: d.put_notional || 0
                                })),
                                borderColor: '#ef4444',
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 5,
                                tension: 0.4,
                                fill: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        layout: { padding: { top: 0 } },
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'minute',
                                    displayFormats: { 
                                        minute: 'MMM dd HH:mm'
                                    },
                                    minUnit: 'minute'
                                },
                                ticks: {
                                    color: '#94a3b8',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    autoSkip: true,
                                    maxTicksLimit: 20,
                                    callback: function(value, index, ticks) {
                                        const date = new Date(value);
                                        const minutes = date.getMinutes();
                                        // Only show labels at 00 and 30 minutes
                                        if (minutes === 0 || minutes === 30) {
                                            return date.toLocaleString('en-US', { 
                                                month: 'short', 
                                                day: 'numeric',
                                                hour: '2-digit',
                                                minute: '2-digit',
                                                hour12: false
                                            });
                                        }
                                        return null;
                                    }
                                },
                                grid: { 
                                    color: function(context) {
                                        const date = new Date(context.tick.value);
                                        const minutes = date.getMinutes();
                                        return (minutes === 0 || minutes === 30) ? '#475569' : '#334155';
                                    }
                                }
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: 'Notional Value ($)', color: '#94a3b8' },
                                ticks: { 
                                    color: '#94a3b8',
                                    callback: function(value) {
                                        // Format as millions or billions
                                        if (value >= 1e9) {
                                            return '$' + (value / 1e9).toFixed(2) + 'B';
                                        } else if (value >= 1e6) {
                                            return '$' + (value / 1e6).toFixed(1) + 'M';
                                        } else if (value >= 1e3) {
                                            return '$' + (value / 1e3).toFixed(0) + 'K';
                                        }
                                        return '$' + value.toFixed(0);
                                    }
                                },
                                grid: { color: '#334155' }
                            }
                        },
                        plugins: {
                            legend: { 
                                labels: { color: '#e2e8f0' },
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        const value = context.parsed.y;
                                        if (value >= 1e9) {
                                            label += '$' + (value / 1e9).toFixed(2) + 'B';
                                        } else if (value >= 1e6) {
                                            label += '$' + (value / 1e6).toFixed(1) + 'M';
                                        } else if (value >= 1e3) {
                                            label += '$' + (value / 1e3).toFixed(0) + 'K';
                                        } else {
                                            label += '$' + value.toFixed(0);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                console.log('OI chart created successfully');

                // Update the SPY quote panel with the most recent data point from chart
                if (filteredData.length > 0) {
                    const latestData = filteredData[filteredData.length - 1];
                    // Use the ACTUAL database timestamp (not the 5-min bucket time)
                    const latestTime = new Date(latestData.actual_timestamp || latestData.timestamp);

                    // Fetch the actual previous day's close for accurate change calculation
                    try {
                        const changeResponse = await fetch('/api/spy-change');
                        const changeData = await changeResponse.json();

                        const priceChange = changeData.change || 0;
                        const percentChange = changeData.percent_change || 0;
                        const changeColor = priceChange >= 0 ? '#10b981' : '#ef4444';
                        const changeSymbol = priceChange >= 0 ? '+' : '';

                        document.getElementById('spyLatest').innerHTML = `
                            <div style="display: flex; justify-content: space-around; align-items: center; padding: 8px;">
                                <div style="text-align: center;">
                                    <div class="metric-label">SPY PRICE</div>
                                    <div style="display: flex; align-items: baseline; justify-content: center; gap: 12px;">
                                        <div class="metric-value" style="font-size: 32px;">$${latestData.close.toFixed(2)}</div>
                                        <div style="color: ${changeColor}; font-size: 18px; font-weight: 600;">
                                            ${changeSymbol}$${Math.abs(priceChange).toFixed(2)} (${changeSymbol}${percentChange.toFixed(2)}%)
                                        </div>
                                    </div>
                                </div>
                                <div style="text-align: center;">
                                    <div class="metric-label">VOLUME</div>
                                    <div class="metric-value" style="font-size: 20px;">${formatNumber(latestData.volume)}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div class="metric-label">DATA AS OF</div>
                                    <div class="metric-value" style="font-size: 14px;">${latestTime.toLocaleString('en-US', { 
                                        month: 'short', 
                                        day: 'numeric', 
                                        hour: '2-digit', 
                                        minute: '2-digit',
                                        second: '2-digit'
                                    })}</div>
                                </div>
                            </div>`;
                    } catch (error) {
                        console.error('Error fetching SPY change data:', error);
                        // Fallback without change data
                        document.getElementById('spyLatest').innerHTML = `
                            <div style="display: flex; justify-content: space-around; align-items: center; padding: 8px;">
                                <div style="text-align: center;">
                                    <div class="metric-label">SPY PRICE</div>
                                    <div class="metric-value" style="font-size: 32px;">$${latestData.close.toFixed(2)}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div class="metric-label">VOLUME</div>
                                    <div class="metric-value" style="font-size: 20px;">${formatNumber(latestData.volume)}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div class="metric-label">DATA AS OF</div>
                                    <div class="metric-value" style="font-size: 14px;">${latestTime.toLocaleString('en-US', { 
                                        month: 'short', 
                                        day: 'numeric', 
                                        hour: '2-digit', 
                                        minute: '2-digit',
                                        second: '2-digit'
                                    })}</div>
                                </div>
                            </div>`;
                    }
                }

            } catch (error) { 
                console.error('Error in updateSPYChart:', error);
                console.error(error.stack);
            }
        }

        async function updateIngestion(data) {
            if (!data.database || !data.database.ingestion_metric) {
                document.getElementById('ingestionLatest').innerHTML = '<div style="color: #64748b;">No ingestion metrics available</div>';
                return;
            }
            const im = data.database.ingestion_metric;
            const imTime = new Date(im.timestamp);
            document.getElementById('ingestionLatest').innerHTML = `
                <div class="grid">
                    <div class="metric"><div class="metric-label">Records Ingested</div><div class="metric-value">${formatNumber(im.records_ingested || 0)}</div></div>
                    <div class="metric"><div class="metric-label">Errors</div><div class="metric-value">${im.error_count || 0}</div></div>
                    <div class="metric"><div class="metric-label">Processing Time</div><div class="metric-value">${im.processing_time_ms || 0}ms</div></div>
                    <div class="metric"><div class="metric-label">Heartbeat Count</div><div class="metric-value">${formatNumber(im.heartbeat_count || 0)}</div></div>
                </div>
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #334155; color: #94a3b8; font-size: 12px;">Last Update: ${imTime.toLocaleString()}</div>`;
            await updateIngestionCharts();
        }

        async function updateIngestionCharts() {
            try {
                // Check cache first
                if (isCacheValid('ingestion') && chartDataCache.ingestion.data.length > 0) {
                    console.log('Using cached ingestion data');
                    const data = chartDataCache.ingestion.data;
                } else {
                    const response = await fetch('/api/ingestion-history');
                    const data = await response.json();
                    if (data.error || data.length === 0) { 
                        console.log('No ingestion history'); 
                        return; 
                    }

                    // Update cache
                    updateCache('ingestion', data);
                }

                const data = chartDataCache.ingestion.data;

                // Aggregate by hour
                const hourlyData = {};
                data.forEach(d => {
                    const date = new Date(d.timestamp);
                    const hourKey = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours()).getTime();

                    if (!hourlyData[hourKey]) {
                        hourlyData[hourKey] = { records: 0, errors: 0 };
                    }
                    hourlyData[hourKey].records += (d.records_ingested || 0);
                    hourlyData[hourKey].errors += (d.error_count || 0);
                });

                const sortedHours = Object.keys(hourlyData).sort((a, b) => a - b);

                if (charts.ingestionCombined) charts.ingestionCombined.destroy();
                const ctx = document.getElementById('ingestionCombinedChart');
                charts.ingestionCombined = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        datasets: [
                            {
                                label: 'Records Ingested',
                                data: sortedHours.map(hour => ({
                                    x: parseInt(hour),
                                    y: hourlyData[hour].records
                                })),
                                backgroundColor: 'rgba(96, 165, 250, 0.8)',
                                borderColor: '#60a5fa',
                                borderWidth: 1,
                                stack: 'combined'
                            },
                            {
                                label: 'Errors',
                                data: sortedHours.map(hour => ({
                                    x: parseInt(hour),
                                    y: hourlyData[hour].errors
                                })),
                                backgroundColor: 'rgba(239, 68, 68, 0.8)',
                                borderColor: '#ef4444',
                                borderWidth: 1,
                                stack: 'combined'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: {
                                type: 'time',
                                stacked: true,
                                time: {
                                    unit: 'hour',
                                    displayFormats: { hour: 'MM/dd HH:mm' }
                                },
                                ticks: { color: '#94a3b8', maxRotation: 45, minRotation: 45 },
                                grid: { color: '#334155' }
                            },
                            y: {
                                type: 'linear',
                                stacked: true,
                                title: { display: true, text: 'Count per Hour', color: '#94a3b8' },
                                ticks: { color: '#94a3b8' },
                                grid: { color: '#334155' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#e2e8f0' } },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toLocaleString();
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) { console.error('Error updating ingestion charts:', error); }
        }

        function updateOptions(data) {
            if (!data.database || !data.database.recent_options || data.database.recent_options.length === 0) {
                document.getElementById('optionsTableBody').innerHTML = '<tr><td colspan="15" style="text-align: center; color: #64748b;">No recent options available</td></tr>';
                return;
            }
            let html = '';
            data.database.recent_options.forEach(opt => {
                const optTime = new Date(opt.timestamp);
                html += `<tr>
                    <td>${opt.symbol || 'N/A'}</td>
                    <td>$${opt.strike?.toFixed(0) || 'N/A'}</td>
                    <td>${opt.expiration || 'N/A'}</td>
                    <td>${opt.dte !== null && opt.dte !== undefined ? opt.dte : 'N/A'}</td>
                    <td>${opt.option_type || 'N/A'}</td>
                    <td>$${opt.last?.toFixed(2) || 'N/A'}</td>
                    <td>$${opt.bid?.toFixed(2) || 'N/A'}</td>
                    <td>$${opt.ask?.toFixed(2) || 'N/A'}</td>
                    <td>$${opt.mid?.toFixed(2) || 'N/A'}</td>
                    <td>${formatNumber(opt.volume || 0)}</td>
                    <td>${formatNumber(opt.open_interest || 0)}</td>
                    <td>${opt.implied_vol !== null && opt.implied_vol !== undefined ? (opt.implied_vol * 100).toFixed(1) + '%' : 'N/A'}</td>
                    <td>${opt.delta !== null && opt.delta !== undefined ? opt.delta.toFixed(3) : 'N/A'}</td>
                    <td>${opt.gamma !== null && opt.gamma !== undefined ? opt.gamma.toFixed(4) : 'N/A'}</td>
                    <td style="font-size: 11px;">${optTime.toLocaleTimeString()}</td>
                </tr>`;
            });
            document.getElementById('optionsTableBody').innerHTML = html;
        }

        async function updateUptimeChart() {
          try {
              const response = await fetch('/api/uptime-history');
              const data = await response.json();
              if (data.error || data.length === 0) { 
                  console.log('No uptime history'); 
                  return; 
              }

              if (charts.uptime) charts.uptime.destroy();
              const ctx = document.getElementById('uptimeChart');

              // Prepare data with colors based on uptime percentage
              const chartData = data.map(d => ({
                  x: new Date(d.timestamp).getTime(),
                  y: d.uptime_percent,
                  checks: d.total_checks,
                  up: d.up_checks
              }));

              charts.uptime = new Chart(ctx, {
                  type: 'bar',
                  data: {
                      datasets: [{
                          label: 'Uptime %',
                          data: chartData,
                          backgroundColor: chartData.map(d => {
                              if (d.y === 0) return 'rgba(239, 68, 68, 0.8)';  // Red - down
                              if (d.y < 50) return 'rgba(251, 146, 60, 0.8)';  // Orange - poor
                              if (d.y < 90) return 'rgba(250, 204, 21, 0.8)';  // Yellow - degraded
                              return 'rgba(16, 185, 129, 0.8)';  // Green - good
                          }),
                          borderColor: chartData.map(d => {
                              if (d.y === 0) return '#ef4444';
                              if (d.y < 50) return '#fb923c';
                              if (d.y < 90) return '#facc15';
                              return '#10b981';
                          }),
                          borderWidth: 1
                      }]
                  },
                  options: {
                      responsive: true, 
                      maintainAspectRatio: false,
                      animation: false,
                      scales: {
                          x: {
                              type: 'time',
                              time: {
                                  unit: 'hour',
                                  displayFormats: { 
                                      hour: 'MM/dd HH:mm'
                                  },
                                  tooltipFormat: 'MMM dd HH:mm'
                              },
                              min: Date.now() - (48 * 60 * 60 * 1000), // Exactly 48 hours ago
                              max: Date.now(),
                              ticks: { 
                                  color: '#94a3b8',
                                  maxRotation: 45,
                                  minRotation: 45,
                                  autoSkip: true,
                                  maxTicksLimit: 16
                              },
                              grid: { color: '#334155' }
                          },
                          y: { 
                              min: 0, 
                              max: 100,
                              title: { 
                                  display: true, 
                                  text: 'Uptime %', 
                                  color: '#94a3b8' 
                              }, 
                              ticks: { 
                                  color: '#94a3b8',
                                  callback: function(value) {
                                      return value + '%';
                                  }
                              }, 
                              grid: { color: '#334155' } 
                          }
                      },
                      plugins: { 
			  marketHoursBackground: false,
                          legend: { 
                              display: false
                          },
                          tooltip: { 
                              callbacks: { 
                                  title: function(context) {
                                      const date = new Date(context[0].parsed.x);
                                      return date.toLocaleString('en-US', {
                                          month: 'short',
                                          day: 'numeric',
                                          hour: '2-digit',
                                          minute: '2-digit',
                                          timeZone: 'America/New_York',
                                          timeZoneName: 'short'
                                      });
                                  },
                                  label: function(context) {
                                      const dataPoint = chartData[context.dataIndex];
                                      return [
                                          `Uptime: ${context.parsed.y.toFixed(1)}%`,
                                          `Up: ${dataPoint.up} / ${dataPoint.checks} checks`,
                                          dataPoint.checks === 0 ? 'No data for this hour' : ''
                                      ].filter(Boolean);
                                  }
                              } 
                          } 
                      }
                  }
              });

              console.log('Uptime chart updated with', data.length, 'hourly buckets');
          } catch (error) { 
              console.error('Error updating uptime chart:', error); 
          }
      }

        function updateDashboard() {
            fetch('/api/metrics').then(response => response.json()).then(data => {
                globalData = data;

                // Parse timestamp safely
                let timestamp;
                try {
                    if (data.timestamp) {
                        timestamp = new Date(data.timestamp);
                        if (isNaN(timestamp.getTime())) {
                            console.error('Invalid timestamp from API:', data.timestamp);
                            timestamp = new Date();
                        }
                    } else {
                        timestamp = new Date();
                    }
                } catch (e) {
                    console.error('Error parsing timestamp:', e);
                    timestamp = new Date();
                }

                document.getElementById('lastUpdate').textContent = `üöÄ Updated: ${timestamp.toLocaleTimeString()}`;

                // Update market status badge separately
                updateMarketStatus();

                updateHome(data);
                updateSystem(data);
                updateServices(data);
                updateDatabase(data);
                updateAlerts(data);
                updateSPY(data);
                updateIngestion(data);
                updateOptions(data);
            }).catch(error => { 
                console.error('Error fetching metrics:', error); 
                document.getElementById('lastUpdate').textContent = 'üöÄ Updated: Connection Error';
            });
        }

        // Initial load
        updateDashboard();
        updateUptimeChart();
        updateSPYChart();
        updateIngestionCharts();

        // Update main dashboard data every 5 seconds
        setInterval(updateDashboard, 5000);

        // Update SPY charts every 5 seconds (independent of dashboard)
        setInterval(() => {
            // If we're on the SPY page, also update the quote panel
            if (document.getElementById('spy').classList.contains('active')) {
                if (globalData && globalData.database) {
                    updateSPY(globalData);
                }
            }
            updateSPYChart(); 
        }, 5000);

        // Update other charts every 5 seconds
        setInterval(() => { 
            updateUptimeChart(); 
            updateIngestionCharts(); 
        }, 5000);

    </script>
</body>
</html>
